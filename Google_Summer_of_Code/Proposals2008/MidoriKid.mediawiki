= Overview =

'''Protocol Test Suites for tpserver-cpp and libtpproto-cpp'''

This is a proposal for protocol test suites for tpserver-cpp and libtpproto-cpp as suggested by the "Protocol compliance test suite" on the Thousand Parsec ideas page.
          
          
= Deliverables =
== Tests for Serialization of Frames ==

Unit tests will be written for each type of frame a library is expected to serialize.  These will consist of manually creating the frame then comparing its serialization with the expected result.  Many tests may be written for a particular frame type depending on its complexity.  Refer to the [[MidoriKid's proposal for GSoC#Example Unit Tests|examples]] at the end of this document for unit tests that fall under this category.

== Tests for Deserialization of Frames ==
A number of unit tests will be written for each type of frame a library is expected to deserialize.  

* pass pregenerated byte streams to the library and check that the resulting frame objects contain the correct values.

* pass byte streams with extremely large, or unexpected (but still within the limits of the protocol) values for frame elements

* pass malformed byte streams and check that they are properly rejected

Besides providing more stable interoperability between different clients and servers, these tests will also provide protection against maliciously malformed frames.

== Tests for Frame Responses and Sequences==

Isolated frame tests don't provide complete coverage of the protocol.  For example, a sequence frame must be followed with the correct number of response frames and a bad request should be responded to with the correct error frame. Higher level tests will be written to cover cases where multiple frames must be considered.  Mock objects will be set up so only the relevant library objects must be instantiated and the state of an entire server won't have to be worried about.

= Benefits =
The benefits of unit testing are well known.  Each part of the software to be tested is isolated from each other allowing the location of bugs to be more quickly found.  They can allow a library to be refactored while making sure it still works correctly.

== Interoperability ==
A project like Thousand Parsec stands to benefit even more.  Several different servers and clients all rely on each other to correctly implement the communication protocol.  If a client developer, for example, experiences problems when connecting to a server then bugs in the server can be ruled out as a cause if the server's implementation of the protocol has been  verified as correct.

== Security ==
In addition to verifying the correct behavior under normal circumstances, tests can be written to test a library's ability to handle malformed data.  Such data may come from a malicious frame, or simply a noncompliant library.  Either way, an error message is preferable to a crash or exploit and a comprehensive test suite can ensure the correct response.

== Unit Testing vs. System Testing ==
Unit tests are compiled as one or more executables each containing several (possibly hundreds or thousands) of individual tests.  Each executable is a stand-alone unit and does not connect to a server or client to test for protocol compliance.  Instead, the components of the library to be tested are compiled as part of the test executable.  Individual tests then instantiate classes and call functions provided by the library and check that the results are correct.  This property of unit testing prevents one test suite from testing different libraries.  Some example unit tests are given below.

Unit testing differs from system testing in that only small parts of the whole are tested at a time.  As an example, one possible way to run a system test on tpserver-cpp would be to write a "test client" that connects to a running server and sends request frames.  The reply frames would then be tested for protocol conformance.

This type of black-box testing is beneficial in that one test client can test all types of servers.  It also ensures that the server works as expected when compiled and run.  It suffers from several drawbacks, however.

*The internal state of the server "black-box" is not known.  Even if the server started at a known state (loaded from a persistence database, for example), during the course of a test that state would change.  Because of this, test failures may be caused by earlier tests or simply the passage of time.  This leads to lost time when searching for the source of test failures.

*The part of the server that must be tested (protocol compliance, for example) depend on parts that may not be correct themselves.  As an example, consider a test client that requests a frame from a server running a known test database.  If the contents of the reply frame don't match the contents of the test database, then there may be an error in the portion of the server that serializes the reply frame.  There may also be an error in the persistence module or anything that handles the data between the two.

There is a place for whole system testing, but it leaves large gaps in coverage and makes the bugs that it does find difficult to track down.

= Roadmap/Plan =

== Tools ==
The unit tests will be implemented using the Boost Test Library.  Many testing frameworks are available for C++.  This library was chosen because of its portability and flexibility.  Additionally, I have extensive experience in its use so no time will be lost to the learning curve.

== Organization ==
A separate top level suite will be created for both tpserver-cpp and libtpproto-cpp.  Each of these suites will have separate, lower-level suites covering the areas mentioned in the deliverables.

Individual frame tests will initialize the library with some minimal test objects and request a frame to be generated.  This will then be compared to a manually generated frame.

Testing sequences of frames will involve creating a "scaffold" of mock objects around the relevant parts of the library.  Requests will be fed in and generated responses will be compared to the responses dictated by the protocol definition. 

== Milestones ==

* '''2008-06-02:''' 
** The test framework will be integrated into each library's build system.
** At least one frame type will be tested for each library.  

* '''2008-06-09:''' 
** All all frames types with five or fewer elements will be tested for correct serialization.

* '''2008-06-16:'''
** All frame types in protocol version 0.3 will be tested for correct serialization.

* '''2008-06-23:''' 
** All frame types in protocol version 0.4 will be tested for correct serialization.

* '''2008-07-07:''' 
** All frame types will be tested for correct deserialization.
 
* '''2008-07-28:''' 
** All frame sequences as specified by the protocol will be tested.

== Potential Risks and Problems ==

Unit testing the libraries will involve breaking them into the smallest possible parts.  Although my initial browse through the source indicates otherwise, it's possible that intermodule coupling will make this difficult.  If this is the case, I'll make efforts to refactor the libraries to make testing easier.  This will have the added benefit of reducing coupling.

Another possibility is that there will be no problems at all and the tests will be completed much earlier than expected.  I've outlined a few smaller projects that I could complete with the remaining time.

* '''Fix exposed bugs:''' Any bugs exposed by testing that haven't already been addressed will be worked on.
* '''Simple conformance testing for libtpproto-py serialization:''' Although there will be no actual code overlap between a C++ unit test executable and a Python unit test module, it should be relatively easy to port the basic serialization tests to Python.  This would be almost entirely separate from the main project. 
* '''Boost.Random integration:''' Unrelated to conformance testing, but within my area of expertise is changing tpserver-cpp to use Boost.Random as its psuedorandom number generator.  I've previously worked with this library as the base for a Perlin noise planet generator and I could drop it into the code if a few extra days are left over before the end of summer.

= Biography and Qualifications =
I'm currently a junior at the University of Nevada, Reno, earning a Bachelor's degree in computer science.  I am maintaining a cumulative GPA of 3.88.

Although my formal education in the subject started only two years ago, I have extensive experience in C++ as a hobbyist game programmer.  I've found code in my archives dating from 16 years ago and for the last four years I've used test-driven development for all of my personal and university projects.

One of my most recent personal projects showcases my testing abilities well.  It's an entity/component system for combining various libraries into a game engine.  It's conveniently accessible from a public git repository: http://repo.or.cz/w/MidoriGraph.git .

I first became interested in Thousand Parsec after searching for an alternative to the Master of Orion series.  Although they were long time favorites of mine, it was becoming harder and harder to run them on modern systems and I was frustrated with bugs I couldn't fix because of their closed nature.  Since then I've contributed several small patches to the project.

== Availability and Communication ==
During my last break from school I was active on the Thousand Parsec IRC channel and the tp-devel mailing list and, if selected, will continue to do so.

My progress can be monitored through my git commits.  I plan on making frequent commits with detailed log messages.  If given repository permissions, these logs will be visible as my own, temporary branch.  Otherwise, I have the facilities to make my personal repository available on the web.

I have no other courses or personal commitments this summer and should be able to devote a substantial amount of time to the project.

= Example Unit Tests =

What follows are two, trivial unit tests for simple libtpproto-cpp frame data serializations.  More complex frame types will have more complex (and numerous) unit tests.  This hasn't been compiled and may not work, but it gives the general idea.

<pre>
#include <string>
#include <boost/test/auto_unit_test.hpp>

#include "buffer.h"
#include "connect.h"
#include "ping.h"

using namespace TPProto;

/*! Ensure ping frame data is empty
 */
BOOST_AUTO_TEST_Case (ping_data) {
    
    Ping frame;
    Buffer data;
    frame.packBuffer(data);

    BOOST_CHECK_EQUAL(data.getLength(), 0);
}


/*! Ensure a connect frame with a small client string is serialized correctly
 */
BOOST_AUTO_TEST_Case (connect_data) {
    
    Connect frame;
    frame.setClientString("foobar");
    Buffer data;
    frame.packBuffer(data);

    // The length is -required- to be correct before continuing to check each
    // character.  Prevents reading past the end of the buffer.
    BOOST_REQUIRE_EQUAL(data.getLength(), 4 + 6);

    // The length of the string is converted to big-endian format manually.
    BOOST_CHECK(!strncmp(data.getData(), "\x00000006" "foobar", 4 + 6));
}
</pre>

JD "MidoriKid" Marble