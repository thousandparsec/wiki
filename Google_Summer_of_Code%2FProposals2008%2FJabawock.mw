=Space Empires III ruleset for Thousand Parsec=

As a project for this year’s GSoC, I’d like to implement a ruleset for the game Space Empires III in the Thousand Parsec framework. I really like this game, and am willing to explore it in detail to be able to implement the rules behind it. I don’t aim at a perfect clone though; I’ll probably tweak some concepts here and there to make it (in my opinion) more interesting. I think it makes a pretty nice GSoC project, as it has a useful purpose (to have a popular game under the Thousand Parsec framework), is an interesting project for a student, and is a good opener to the open source development community.

Implementing a ruleset within the existing framework is, in itself, not too difficult. The biggest part of the design is already done, so I’d just have to use it for this particular game. I’ve looked into the framework’s code, and it looks straightforward enough not to spend too much time figuring it out. The already existing examples (like RFTS) should also be very helping. 
What has to be done though, is deciding what exactly to implement. In fact, SEIII is not the basic 4X game, as it has a more or less high level of detail. This gives a relatively complex universe, which cannot be entirely implemented over the course three months. So, choices have to be made, to narrow down all of the rules to a reasonable base, which would still provide an interesting game to play. 

==Insights into the game==

Here is a short description of Space Empires III, based on the shareware version of the game (which is quite enough for a three months project); in this game, a player starts with a single planet, and aims at colonizing other planets and systems, as well as warring with other players. To travel between systems, ships need to go through worm holes, which “teleports” them into the next system. To colonize planets in these systems, he needs colonizer ships, conceived to colonize a particular type of planet. In fact, planets have various types of atmosphere, and each requires a different technology to colonize. Once he colonized a planet, he may build facilities on the ground. Construction, research and intelligence centers produce respectively construction, research and intelligence points. Space ports transfer all the points produced to the player in order for him t use them (one space port is needed on every system where points are being produced). Resupply depots allow friendly ships to resupply in their long travel. There are also planetary shields and missiles, to defend the planet from invaders.

To war with his enemies, the player needs battle ships, which he can, like other ships in the game, design freely, using the components he has access to. The combat system is the usual damage points system; actually, damage Is dealt to the ship’s components. So a ship which has taken 4 points of damage might become totally useless of only slightly damaged, depending on the destroyed components. A battle between ships (or ships and a planet) begins if the attacker tries to move on the same square as the defender, and wants to attack him. A battle is divided into combat turns, where both the attacker and defender fire and move. A battle ends when one of the two sides has been annihilated, or if a certain number of combat turns passed. In that case, the battle is drawn, and both parties remain on the same square.

Research can be used for various purposes, like develop better ship components, faster ship construction, ability to colonize a particular type of atmosphere… Quite a lot of technology levels are available. 

Basic diplomacy and alliances, which enables trade between players, are also available.

==Objects==

Formally, here are the objects of this game and their properties.

===Objects which cannot be owned by a player===
* Systems:  Can contain one star, planets and space storms (which make passing by ships invisible), and at least one worm hole. All systems have the same size.
* Worm holes: Link two systems together.

===Owned objects===
* Planets: Have 6 possible atmosphere types, a size (influencing the maximum number of facilities), a population, a population happiness (influencing population growth), the demanded production rate (influencing population happiness), a value (influencing productivity), and planetary conditions (influencing population growth). Planets with more than 100M inhabitants get an inbuilt ship yard, so ships can be constructed. A colony on a planet can be destroyed by attacking ships, if the population gets to 0. All the facilities are then destroyed. 
* Ships: Have a design, speed and time left before out of supplies. A ship can be anywhere, except on a square where a battle occurs.
* Designs: Are made of a ship type and a set of components, located into one of the three hulls (inner, middle and outer). These hulls determine which components will be destroyed first. Ship types determine how many components can fit in and the actions that can be performed by the ship. There also are requirements for using a particular ship type, like the need of some specific components (crew quarters, life support…). Designs also have a cost, which is the sum of its components’ costs and the cost of the ship type. They can be labeled as prototype if no ships we ever build using that design.
* Components: Grand a benefit to the ship, depending on the type of component. A component type can be, for example, shield generator, and the component could then be shield generator 1, 2, 3… Components can either be operational, under construction, or destroyed. In the last two cases they need to be constructed or repaired (which is actually the same thing), and do not grand any benefit to the ship.

===Orders that can be given to owned objects===

* Planets: Add new facility in building queue, change the demanded production rate, build or repair a ship with the inbuilt ship yard.
* Ships: Move to a given position, attack or perform a special action (colonize, load population…). The resupply is automatic if the ship is next to a planet with a resupply depot. Reparations are also automatic if it is next to a ship yard. A ship can be purchased if the player can afford it. 
* Designs: Can be changed if in the state of prototype.
* Components: Some components have a special function which can be ordered, like the self destructing device.

==End of turn processing==

Here are the different things happening at the end of the turn. The order is not really important here, except maybe for intelligence operations, which may damage ships and should come last. 

* Ship movements, special actions and battles.
* Point production.
* Population growth.
* Construction of facilities.
* Ship repairs.
* Spending of research points, unlocking of new components.
* Intelligence operations.

==Clustering the rules==

The start of the project is to cluster the rules of SEIII into categories (or layers as I’ll call them). These layers are ordered by importance, and any layer should not depend on the next one. This way, I’ll be able to implement and fully test one layer at a time, incrementally. Here is how I would cluster the rules:
* Layer 1: 	
** Planets and systems, with worm holes. Planet characteristics (size, value, population growth and happiness, atmosphere) are all there.
** Facilities: Only construction centers, space ports, and maybe ship yards as facilities too (they wouldn’t take up space on the planet though).
** Notion of points (research and construction) and point storage.
** Ships: Only some pre-built designs, no customization. 
** Simple combat system (no tactical combat).
* Layer 2:
** Add all the usual facility types, but no planetary battles (no troops….), and no intelligence.
** Add real components to ships, which can then be customized at will.
** Research unlocks new or better ship components, as well as sizes and types.
** Real damage system of SEIII: destruction of individual components of a ship.
* Layer 3:
** Add a complete research system, with plenty of levels.
** Add basic intelligence.
** Add some minor left out things.

There are only three layers here, but I’ll probably divide them into more, to be able to test each thing separately. I think layer 1 is the minimum requirement for a decent game though.

==Schedule==

With these layers in mind, here’s a basic schedule for the project:
* 14/04: Think of how to fit the layer 1 rules in the framework, and design a rough class diagram (I won’t spend too much time on formal modeling).
* End of April: Start implementing the layer 1.
* Halfway through May: Start preparing for the exams; continue the project from time to time.
* 24/06 (more or less): End of exam period, continue coding on full time.
* First deadline: Must have finished with layer 1. The last week before the deadline should be used for testing.
* Second half of the project: design and code layer 2, same for layer 3 if enough time.
* Final deadline: Must have at least completed and tested layer 2. 
I clustered the rules in order to give me some margin. This way, I can have something to deliver for the final deadline even if the coding in the second stage was delayed. If it happens that I cannot finish layer 3 on time, I’ll probably finish it after GSoC. I may also implement more additional rules afterwards if time allows for it.
In the early stages of the project I’ll work on the project on week ends and evenings of week days. It is convenient that all of my university projects will be finished by April 13th. During my exams I’ll try to work on the project too, but on an irregular basis, finding some spare time here and there. After the exams are over I don’t have any planned activities, so I can spend most of my time coding and testing (like on a full time job).

==Personal background==
My name is Boris Iolis (Jabawock on the forum), and I’m in my third year of computer science study at the ULB (in Brussels). I’m interested in this project because it is a way to use all of the knowledge I acquired to make a game that people will actually play (and not just rate like in university), which is really important to me. Combined with the fact that the project is about a game I like a lot, it makes my determination very strong. Also, I feel that it is a great opportunity to discover the world of open source software, which I am not particularly familiar with. 
I don’t have much related experience, except for an ant colony simulation I worked on with a group of people last year. As a turn based simulation, it has common points with 4X games. It was the biggest programming project I worked on, and I learned a lot through it, especially not to underestimate the amount of work. Thinking of a schedule is easy, but things quickly go off track and delays occur. That’s why I divided my project into layers; to ensure that, whatever happens, there will be something coherent to deliver for the deadline.

==Communication==
I understand that communication is very important in this kind of project, so I’ll keep contact with developers of Thousand Parsec as much as possible, to keep them informed of the progress I make. I’ll be active in the mailing list and forum, and creating a blog about the project seems like a good idea too. 
I have a problem with IRC though; I live in a student room, and my internet connection is provided by my university. IRC must be blocked somehow because I can’t connect with any IRC client. There won’t be problems in the second stage of the project though, as I’ll be at my parent’s house and will be able to connect freely from there.
Contact: biolis@ulb.ac.be

==Feedback==
Feel free to leave any comments on this proposal draft. I don’t know what level of detail is necessary; I’ll dig deeper if it’s not enough.  I’m sorry I didn’t have the opportunity to ask more questions about all this before, mostly because I couldn’t get on IRC and was very busy.

----

You say that you have already some some game programming in university, maybe you could put these examples (or any other that you have done) somwhere on the internet if they are relevant to this application.

I guess we all here prefer the dates in ISO standard format, like YYYY-MM-DD. This makes it the most clear which one is month and which one is day.

If you have already explored which ruleset elements (objects, orders, ...) are not doable with current protocol specification (version 3) write this down. Is it OK with version 4 which is in the works? Maybe something will need to be added to TP04 to make it possible to create the fuller ruleset.

Oh yeah, don't forget to mention which language you will use. If I remember correctly it is C++. So that we know for which server this is going to be.
--[[User:JLP|JLP]] 05:33, 25 March 2008 (EDT)
