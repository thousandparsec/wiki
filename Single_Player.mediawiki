'''Single-player mode''' is a cross-client effort to allow users to configure a local server and AI opponents automatically via an easy wizard interface. This is being developed for [[Google Summer of Code]] 2008 by Aaron Mavrinac / [[User:Ezod|ezod]].

==Configuration==

Configuration in tpclient-pywx will be done via a wizard-style interface available from the initial "Connect To Server" screen. The wizard is a user-friendly front end to the functions in the SinglePlayer module of libtpclient-py.

===Flowchart===

[[images/SinglePlayerFC.png|Single-Player Configuration Flowchart]]

===Implementation===

The SinglePlayerGame object in libtpclient-py provides all back end functionality:

 from tp.client.SinglePlayer import SinglePlayerGame
 game = SinglePlayerGame()

The player first chooses a ruleset from the ruleset list:

 print 'SELECT RULESET'
 while game.rname not in game.rulesets:
     game.rname = raw_input('Choose a ruleset from ' + str(game.rulesets) + ': ')

If there are multiple servers implementing the chosen ruleset, a server must be chosen:

 slist = game.list_servers_with_ruleset()
 if len(slist) > 1:
     print 'SELECT SERVER'
     print 'There are multiple servers implementing the', game.rname, 'ruleset.'
     while game.sname not in slist:
         game.sname = raw_input('Choose a server from ' + str(slist) + ': ')
 else:
     game.sname = slist[0]

Ruleset options, if any, may be specified:

 paramlist = game.serverlist[sname]['rulesets'][rname]['parameters']
 if len(paramlist):
     print 'RULESET OPTIONS'
     for param in paramlist.keys():
         game.rparams[param] = raw_input(paramlist[param]['longname'] + ' (' + paramlist[param]['type'] + '): ')

Likewise for server options:

 paramlist = game.serverlist[sname]['parameters']
 if len(paramlist):
     print 'SERVER OPTIONS'
     for param in paramlist.keys()
         game.sparams[param] = raw_input(paramlist[param]['longname'] + ' (' + paramlist[param]['type'] + '): ')

Opponents may then be added:

 ailist = game.list_aiclients_with_ruleset()
 while len(ailist) > 0:
     aiuser = raw_input('Enter an opponent name (leave blank to stop adding opponents): ')
     if aiuser:
         ainame = ''
         while ainame not in ailist:
             ainame = raw_input('Please select an AI client from ' + str(ailist) + ': ')
         aiparams = {}
         paramlist = game.ailist[ainame]['parameters']
         for param in paramlist.keys():
             aiparams[param] = raw_input(paramlist[param]['longname'] + ' (' + paramlist[param]['type'] + '): ')
         game.add_opponent(ainame, aiuser, aiparams)

When everything is complete, start the game:

 port = game.start()
 if port:
     # start player's client and connect to localhost:port

Finally, to clean up when the game is done, stop it:

 game.stop()

==Adding Single-Player Support==

In order for a component to be available for single-player mode, it must install an XML description of itself (using tpconfig.dtd) in a shared directory (currently /usr/share/tp). Additionally, servers and AI clients require control scripts with a common interface for starting and stopping the processes.

In the XML files, there are ''forced'' parameters (simply added to the command line as-is) and ''regular'' parameters (offered to the player in the wizard). Any options required for single-player mode (including those which allow for non-interactive control) should be forced parameters; any that are relevant to a single-player game and can be set by the player should be regular parameters.

===Servers===

Server files live in the ''servers'' subdirectory (i.e., /usr/share/tp/servers).

The control script takes 3 required arguments: a start or stop command, the ruleset name, and the TCP port to listen on.

====tpserver-cpp.xml====

 <?xml version="1.0"?>
 <!DOCTYPE tpconfig SYSTEM "../tpconfig.dtd">
 <tpconfig>
   <server name="tpserver-cpp">
     <longname>tpserver-cpp</longname>
     <version>0.5.1</version>
     <description>Thousand Parsec server in C++.</description>
     <forced>--game_load yes</forced>
     <forced>--game_start yes</forced>
     <forced>--network_start yes</forced>
     <forced>--add_players yes</forced>
     <forced>--turn_player_threshold 100</forced>
     <parameter name="turnlength" type="I">
       <longname>Turn Length</longname>
       <description>Maximum length of a turn (0 for unlimited).</description>
       <default>0</default>
       <commandstring>--turn_length_over_threshold %d</commandstring>
     </parameter>
     <ruleset name="minisec">
       <longname>MiniSec</longname>
       <version>0.3</version>
       <description />
     </ruleset>
     <ruleset name="mtsec">
       <longname>MTSec</longname>
       <version>0.0</version>
       <description />
     </ruleset>
   </server>
 </tpconfig>

====tpserver-cpp.init====

 #!/bin/bash
 
 # Single-player control script for tpserver-cpp
 # Copyright 2008 Aaron Mavrinac and the Thousand Parsec Project
 # Distributed under the terms of the GNU General Public License v2
 
 TPBIN="/usr/games/bin/tpserver-cpp"
 TPCMD=$1
 TPNAME=`basename $0 .init`
 
 function startfunc {
   echo "Starting $TPNAME..."
 
   $TPBIN --configure /dev/null \
     --ruleset $TPGAME \
     --tp_port $TPPORT \
     $TPARGS &
 
   if ps ax | grep -v grep | grep $TPBIN > /dev/null; then
     echo "OK."
   else
     echo "$0: error: unable to start $TPNAME"
     exit 1
   fi
 }
 
 function stopfunc {
   echo "Stopping $TPNAME..."
 
   killall $TPBIN
 }
 
 if [ $TPCMD = "start" ]; then
   TPGAME=$2
   TPPORT=$3
   TPARGS=`echo $@ | cut -f4- -d' '`
   startfunc
 elif [ $TPCMD = "stop" ]; then
   stopfunc
 else
   echo "$0: error: unknown command"
 fi
 
 exit 0

===Ruleset Modules===

Rulesets are part of the server they are modules for, and thus also live in the ''servers'' subdirectory. Rulesets built into the server may simply be added to that server's XML file, as shown in tpserver-cpp-0.5.1.xml above, but in cases where the ruleset is installed separately, something like the following may be used. The server name must match the server to which the ruleset belongs.

====tpserver-cpp-risk.xml====

 <?xml version="1.0"?>
 <!DOCTYPE tpconfig SYSTEM "../tpconfig.dtd">
 <tpconfig>
   <server name="tpserver-cpp">
     <ruleset name="risk">
       <longname>Risk</longname>
       <version>0</version>
       <description>A modified Risk ruleset for tpserver-cpp.</description>
       <parameter name="map" type="S">
         <longname>Map</longname>
         <description>Map file to load.</description>
         <default />
         <commandstring>--risk_map %s</commandstring>
       </parameter>
       <parameter name="rfcstart" type="I">
         <longname>Reinforcements</longname>
         <description>Starting reinforcement count.</description>
         <default />
         <commandstring>--risk_rfc_start %d</commandstring>
       </parameter>
     </ruleset>
   </server>
 </tpconfig>

===AI Clients===

AI client files live in the ''aiclients'' subdirectory (i.e., /usr/share/tp/aiclients).

The control script takes 4 required arguments: a start or stop command, the ruleset name, the TCP port to connect to, and a username for the AI opponent.

====daneel-ai.xml====

 <?xml version="1.0"?>
 <!DOCTYPE tpconfig SYSTEM "../tpconfig.dtd">
 <tpconfig>
     <aiclient name="daneel-ai">
         <longname>daneel-ai</longname>
         <version>0</version>
         <description>An advanced rule based AI.</description>
         <rules>risk</rules>
         <rules>rfts</rules>
     </aiclient>
 </tpconfig>

====daneel-ai.init====

 #!/bin/bash
 
 # Single-player control script for daneel-ai
 # Copyright 2008 Aaron Mavrinac and the Thousand Parsec Project
 # Distributed under the terms of the GNU General Public License v2
 
 TPBIN="/path/to/daneel-ai"
 TPCMD=$1
 TPNAME=`basename $0 .init`
 
 function startfunc {
     echo "Starting $TPNAME ($TPUSER)..."
 
     $TPBIN \
         --file rules-$TPGAME \
         --uri tp://$TPUSER:password@localhost:$TPPORT &
 
     #TODO: verify running by pid
     echo "OK."
 }
 
 function stopfunc {
     echo "Stopping $TPNAME..."
 
     #TODO: kill by pid
     killall daneel-ai
 }
 
 if [ $TPCMD = "start" ]; then
     TPGAME=$2
     TPPORT=$3
     TPUSER=$4
     startfunc
 elif [ $TPCMD = "stop" ]; then
     stopfunc
 else
     echo "$0: error: unknown command"
 fi
 
 exit 0

====gencon.xml====

 <?xml version="1.0"?>
 <!DOCTYPE tpconfig SYSTEM "../tpconfig.dtd">
 <tpconfig>
     <aiclient name="gencon">
         <longname>GenCon</longname>
         <version>0</version>
         <description>An AI based around a genetic algorithm.</description>
         <rules>risk</rules>
         <rules>rfts</rules>
         <parameter name="difficulty" type="I">
             <longname>Difficulty</longname>
             <description>Difficulty level (1 - 9).</description>
             <default>8</default>
             <commandstring>%d</commandstring>
         </parameter>
     </aiclient>
 </tpconfig>

====gencon.init====

 #!/bin/bash
 
 # Single-player control script for FakeAI
 # Copyright 2008 Aaron Mavrinac and the Thousand Parsec Project
 # Distributed under the terms of the GNU General Public License v2
 
 TPJAR="/path/to/GenConRunner"
 TPCMD=$1
 TPNAME=`basename $0 .init`
 
 function startfunc {
     echo "Starting $TPNAME ($TPUSER)..."
 
     java $TPJAR \
         $TPGAME \
         tp://$TPUSER:password@localhost:$TPPORT \
         $TPARGS \
         n &
 
     #TODO: verify running by pid
     echo "OK."
 }
 
 function stopfunc {
     echo "Stopping $TPNAME..."
 
     #TODO: kill by pid
     killall GenConRunner
 }
 
 if [ $TPCMD = "start" ]; then
     TPGAME=$2
     TPPORT=$3
     TPUSER=$4
     TPARGS=`echo $@ | cut -f5- -d' '`
     startfunc
 elif [ $TPCMD = "stop" ]; then
     stopfunc
 else
     echo "$0: error: unknown command"
 fi
 
 exit 0


===tpconfig.dtd===

 <!ELEMENT tpconfig (server?, aiclient?) >
 
 <!ELEMENT longname (#PCDATA) >
 <!ELEMENT version (#PCDATA) >
 <!ELEMENT description (#PCDATA) >
 <!ELEMENT forced (#PCDATA) >
 <!ELEMENT default (#PCDATA) >
 <!ELEMENT commandstring (#PCDATA) >
 <!ELEMENT rules (#PCDATA) >
 
 <!ELEMENT parameter (longname?, description?, default?, commandstring?) >
 <!ATTLIST parameter name ID #REQUIRED type NMTOKEN #REQUIRED >
 
 <!ELEMENT ruleset (longname?, version?, description?, forced*, parameter*) >
 <!ATTLIST ruleset name ID #REQUIRED >
 
 <!ELEMENT server (longname?, version?, description?, forced*, parameter*, ruleset+) >
 <!ATTLIST server name ID #REQUIRED >
 
 <!ELEMENT aiclient (longname?, description?, forced*, parameter*, rules+) >
 <!ATTLIST aiclient name ID #REQUIRED >